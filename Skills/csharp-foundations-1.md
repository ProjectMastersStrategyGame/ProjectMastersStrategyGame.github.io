1. Что такое C#?
C# - это язык программирования. Он был создан Microsoft в 2000 году для предоставления современного языка программирования общего назначения, который можно использовать для разработки всех видов программного обеспечения для различных платформ, включая Windows, Web и Mobile, используя только один язык программирования. Сегодня C# является одним из самых популярных языков программирования в мире. Миллионы разработчиков программного обеспечения используют C# для создания всех видов программного обеспечения.

C# является основным языком для создания программных приложений Microsoft .NET. Разработчики могут создавать практически все виды программного обеспечения с использованием C#, включая приложения пользовательского интерфейса Windows, консольные приложения, серверные службы, облачные API, веб-службы, элементы управления и библиотеки, серверные приложения, веб-приложения, приложения для iOS и Android, ПО искусственного интеллекта и машинного обучения, а также блокчейн приложений.

С помощью IDE Visual Studio C# обеспечивает быструю разработку приложений. C# - это современный, объектно-ориентированный, простой, универсальный и ориентированный на производительность язык программирования. C# разработан на основе лучших функций и вариантов использования нескольких языков программирования, включая C++, Java, Pascal и SmallTalk.

Синтаксис C# похож на C++. Библиотека .NET и C# похожа на Java. C# поддерживает современные возможности объектно-ориентированного языка программирования, включая абстракцию, инкапсуляцию, полиморфизм и наследование. C# является строго типизированным языком, и большинство типов наследуются от класса Object.

C# поддерживает концепции классов и объектов. Классы имеют такие элементы, как поля, свойства, события и методы. C# универсален, современен и поддерживает современные потребности программирования. С самого начала язык C# прошел различные обновления. В этом году ожидается релиз C# версии 8.0.

А какой язык программирования самый популярный?
Судя по статистике GitHub - это JavaScript (https://madnight.github.io/githut/#/pull_requests/2020/1, https://www.benfrederickson.com/ranking-programming-languages-by-github-users/) Тенденции так же намечаются в сторону Rust и JS, а не C# (https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-wanted).

Ещё один ресурс для мониторинга популярности:

https://www.tiobe.com/tiobe-index/

2. Что такое объект в C#?
C# - это объектно-ориентированный язык программирования. Классы являются основой C#. Класс - это шаблон, который определяет, как будет выглядеть структура данных, как данные будут храниться, управляться и передаваться. У класса есть поля, свойства, методы и другие члены.

Классы – концептуальные понятия, а объекты реальные. Объекты создаются как экземпляры класса. Класс может иметь столько экземпляров, сколько необходимо. Класс определяет тип объекта. Объекты хранят реальные значения в памяти компьютера.

Любая сущность реального мира, которая может иметь некоторые характеристики или которая может выполнять какую-либо работу, называется объектом или экземпляром, т. е. копией сущности на языке программирования.

Например, нам нужно создать программу, которая занимается автомобилями. Нам можно создать сущность для автомобиля. Назовем это классом Автомобиль. Автомобиль имеет четыре свойства: модель, тип, цвет и размер. Чтобы представить автомобиль в программировании, мы можем создать класс Car с четырьмя свойствами: Model, Type, Color и Size. Они называются членами класса.

Класс имеет несколько типов членов: конструкторы, поля, свойства, методы, делегаты и события. Член класса может быть приватным, защищенным и открытым. Поскольку эти свойства автомобиля могут быть доступны извне класса, они могут быть открытыми.
Например, Honda Civic является экземпляром автомобиля. В программировании Honda Civic - это объект. Свойства Model, Type, Color, and Size автомобиля Honda Civic: Civic, Honda, Red, 4.

Объекты - это сущности реального мира? Получается, что объект C# - это оцифрованный объект  Какой модели из реального мира соответствует, например, экземпляр CarFactory - реализация абстрактной фабрики?

Не совсем. В зависимости от задачи - это абстракции объектов реального, наделённые характеристиками, которые нам интересны для решения конкретной задачи. Совершенно не обязательно, и невозможно, полностью скопировать реальную сущность в объект языка программирования с учётом бесконечного многообразия реальных объектов и контекстов их применения.

Так же могут быть абстракции, которые не имеют ничего общего с объектами реального мира. Например, абстрактная фабрика CarFactory. Этот объект будет служить лишь архитектурным целям.

3. Что Такое Управляемый и Неуправляемый Код?
Управляемый Код
Это код, разработанный с использованием платформы .NET и ее поддерживаемых языков программирования, таких как C# или VB.NET. Управляемый код напрямую выполняется общеязыковой средой исполнения (CLR или Runtime), а его жизненный цикл, включая создание объектов, выделение памяти и удаление объектов, управляется средой исполнения. Любой код, написанный внутри .NET Framework или на языке, поддерживаемом .NET Framework, является управляемым кодом.

Неуправляемый Код
Код, разработанный за пределами .NET Framework, называется неуправляемым кодом.

Приложения, которые не работают под управлением CLR, считаются неуправляемыми. Такие языки, как C или C++ или Visual Basic, неуправляемые. Создание, выполнение и удаление объектов в неуправляемом коде выполняется программистами напрямую. Если программисты пишут плохой код, это может привести к утечкам памяти и нежелательному распределению ресурсов.

.NET Framework предоставляет механизм работы с неуправляемым кодом, который будет использоваться в управляемом коде, и наоборот. Процесс выполняется с помощью классов-обёрток.

4. Чем отличается интерфейс от абстрактного класса в C#?
Это, вероятно, самый часто задаваемый вопрос в мире .Net. Теоретически между абстрактным классом и интерфейсом есть 5 отличий, которые перечислены ниже:

Класс может реализовывать любое количество интерфейсов, но дочерний класс может наследовать только от одного абстрактного класса.
Абстрактный класс может иметь неабстрактные (конкретные) методы, в то время как в случае интерфейса все методы должны быть абстрактными. (Начиная с C# 8 допускается реализация по умолчанию интерфейсных методов).
Абстрактный класс может объявлять или использовать любые переменные, в то время как интерфейсу это запрещено. То есть следующий код приведёт к ошибке компиляции "Interfaces cannot contain fields" ("Интерфейсы не могут содержать полей"):

interface ITestInterface
{
    int x = 4; // Неверное объявление в интерфейсе
    void GetMethod();
    string GetName();
}
 
abstract class TestAbstractClass
{
    int i = 4;
    int k = 3;
    public abstract void GetClassName();
}
Абстрактный класс может иметь объявление конструктора, а интерфейс нет. Возникает аналогичная пункту 3 ошибка компиляции "Interfaces cannot contain constructors" ("Интерфейсы не могут содержать конструкторов")

Абстрактный класс может иметь все модификаторы доступа для всех своих объявлений членов, в то время как в интерфейсе мы не можем объявлять никаких модификаторов доступа для членов (включая public), так как все члены интерфейса неявно открытые. Следующий код приведёт к ошибке компиляции "The modifier 'public' is not valid for this item" ("Модификатор 'public' недопустим для этого элемента"):

interface ITestInterface
{
    public void getMethod();
    public string getName();
}
Абстрактный класс может иметь базовые реализации методов. А интерфейс - нет.
Подождите, а как же реализация интерфейсных методов по умолчанию?
Наиболее спорная фича. Начиная с C# 8 допускается реализация по умолчанию интерфейсных методов.

Основная мотивация для этой функции

Методы интерфейса по умолчанию позволяют автору API добавлять методы в интерфейс в будущих версиях без нарушения исходной или двоичной совместимости с существующими реализациями этого интерфейса.
Эта функция позволяет C# взаимодействовать с API-интерфейсами, предназначенными для Android (Java) и iOS (SWIFT), которые поддерживают аналогичные функции.
Как оказалось, добавление реализаций интерфейса по умолчанию предоставляет элементы функции языка "признаки" (https://en.wikipedia.org/wiki/Trait_(computer_programming)). Признаки являются мощным методом программирования (http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf).
Синтаксис для интерфейсов расширен и теперь в интерфейсах можно объявить:

Тело метода или индексатора, методов доступа к свойству или событию.
Private, protected, internal, public, virtual, abstract, override, sealed, static, extern
Статические поля, методы, свойства, индексаторы, события.
Override модификаторы.
Ключевое ограничение - реализация по умолчанию всё еще не может ссылаться на состояние экземпляра. Технически это выглядит, как невозможность объявить поля в интерфейсе. Только свойства и методы.

В чем концептуальное различие этих двух понятий?
У этих двух механизмов различное назначение:

Интерфейс - это протокол взаимодействия с объектом. Объект, поддерживающий интерфейс, для внешнего кода состоит в отношении "поддерживает функционал".
Абстрактный класс - это способ построения иерархии. Объект, унаследованный от абстрактного класса, для внешнего кода состоит в отношении "является частным случаем от".
5. В чём разница между операторами "continue" и "break" в C#?
Используя оператор break, вы можете «выпрыгнуть из цикла», тогда как, используя оператор continue, вы можете «перепрыгнуть через одну итерацию» и продолжить выполнение цикла.

Пример break:

for (int i = 0; i <= 5; i++)
{
    if (i == 4)
    {
        break;
    }
    Console.WriteLine(i);
    Console.ReadLine();
}

Вывод:

0
1
2
3
Пример continue:

for (int i = 0; i <= 5; i++)
{
    if (i == 4)
    {
        continue;
    }
    Console.WriteLine(i);
    Console.ReadLine();
}
Вывод:

1
2
3
5
6. В чем разница между константой и полем только для чтения в C#?
Поле сonst - это константа; переменная, значение которой является постоянным со времени компиляции. Присваивать значение константе обязательно. По умолчанию поле const является статическим, и мы не можем изменить значение переменной const при выполнении программы.

Поле readonly - это поле, значение которого мы можем изменить или назначить во время выполнения, но только через нестатический конструктор.

Например, у нас есть тестовый класс, в котором у нас две переменные: одна только для чтения, а другая - константа.

class Test
{
    readonly int readOnly = 10;
    const int cons = 10;
 
    public Test()
    {
        read = 100;
        //cons = 100;  // Будет ошибка компиляции.
    }
 
    public void Check()
    {
        Console.WriteLine("Read only: {0}", readOnly);
        Console.WriteLine("Const: {0}", cons);
    }
}

При попытке изменить значение константы в конструкторе возникает исключение "The left-hand side of an assignment must be a variable, property or indexer" ("Левая часть оператора присваивания должна быть переменной, свойством или индексатором").

Если мы создадим экземпляр класса Test и вызовем метод Check(), мы получим следующий вывод:

Read only: 100
Const: 10
Что будет, если я в одной из своих библиотечных сборок изменю значение константы?
При компиляции значения const записываются непосредственно вместо вызывающего константу кода. В предыдущем примере все обращения к cons при компиляции будут заменены на 10. Это может иметь как преимущества, так и недостатки. Код работает гораздо быстрее, так как избегает лишнего вызова, но. Если вам нужно изменить значение константы, вам нужно перекомпилировать все сборки, обращающиеся к ней. Поэтому в общем случае, если к константе обращаются другие сборки, предпочтительнее использовать поле readonly. Также константа бесполезна, если значение выбирается во время выполнения, например, из файла конфигурации.

7. В чем разница между ключевыми словами ref и out?
Ключевые слова ref и out используются для передачи аргументов в метод или функцию. Оба указывают, что аргумент/параметр передается по ссылке. По умолчанию параметры передаются в метод по значению.

Ref
Ключевое слово ref передает аргументы по ссылке. Это означает, что любые изменения, внесенные в этот аргумент в методе, будут отражены в этой переменной, когда управление вернется в вызывающий метод:

public static string GetNextName(ref int id)
{
    string returnText = "Next-" + id;
    id += 1;
    return returnText;
}
 
static void Main(string[] args)
{
    int i = 1;
    Console.WriteLine("Previous value of i:" + i);
    string test = GetNextName(ref i);
    Console.WriteLine(test);
    Console.WriteLine("Current value of i:" + i);
    Console.ReadLine();
}

Вывод:

Previous value of i:1
Next-1
Current value of i:2
Out
Ключевое слово out возвращает аргумент из метода по ссылке. Оно очень похоже на ключевое слово ref.

public static string GetNextName(out int id)
{
    id = 1;
    string returnText = "Next-" + id;
    return returnText;
}
 
static void Main(string[] args)
{
    int i;
    string test = GetNextName(out i);
    Console.WriteLine(test);
    Console.WriteLine("Current value of i:" + i);
    Console.ReadLine();
}

Вывод:

Next-1
Current value of i:1
Отличия
Ref
1. Параметр или аргумент должен быть инициализирован, прежде чем он передаётся в ref.
2. Не требуется присваивать или инициализировать значение параметра (переданного с помощью ref) внутри вызываемого метода перед возвратом в вызывающий метод. Потому что п1.
3. Передача значения параметра с помощью ref полезна, когда вызываемый метод также необходим для изменения переданного параметра.
4. При использовании ref, данные могут передаваться в двух направлениях.

Out
1. Не обязательно инициализировать параметр или аргумент перед его передачей в out. Потому что п2.
2. Вызываемый метод обязан присвоить или инициализировать значение параметра (переданного с помощью out) перед возвратом в вызывающий метод.
3. Передача значения параметра с помощью out полезна, когда из функции или метода необходимо вернуть несколько значений.
4. При использовании out, данные передаются только однонаправленно (от вызываемого метода к вызывающему).

Сходства
1. И ref, и out ведут себя по-разному во время выполнения, но они трактуются одинаково при компиляции.
2. Свойства не являются переменными, поэтому их нельзя передавать как параметр out или ref.

Перегрузка методов
Допустима перегрузка методов, если один метод принимает параметры по значению, а другой по ссылке с помощью ref или out. Однако, поскольку и ref, и out трактуются одинаково при компиляции, методы не могут быть перегружены, если один метод принимает аргумент как ref, а другой - как out. То есть так делать нельзя:

public static string GetNextName(ref int id)
{
    string returnText = "Next-" + id.ToString();
    id += 1;
    return returnText;
}
  
public static string GetNextName(out int id)
{
    id = 1;
    string returnText = "Next-" + id.ToString();
    return returnText;
}

При компиляции этого кода будет выброшено исключение: "Сannot define an overloaded method that differs only on parameter modifiers 'out' and 'ref'" ("Нельзя определить перегруженные методы, которые отличаются только модификаторами 'out' и 'ref'").

Будет ли профит от ref/out, если я передам в метод структуру с большим количеством данных?
Да, будет. Структура - это тип, передаваемый по значению. Если она содержит объемные данные, то при передаче в метод штатными способами вся структура будет скопирована. Если структуру отметить ключевым словом ref, то будет передана только ссылка. В некоторых случаях это может положительно сказаться на производительность.

Но стоит помнить, что изменения структуры внутри метода сохраняться, когда поток выполнения вернётся в вызывающий код. Начиная с версии языка 7.2 для этих целей введен модификатор in, который решает проблему модификации структуры, переданной в метод по ссылке.

8. Можно ли использовать 'this' в статическом методе?
Ключевое слово 'this' в C# является специальным типом ссылочной переменной, которая неявно определяется в каждом конструкторе и нестатическом методе как первый параметр типа класса, в котором она определена.

Мы не можем использовать 'this' в статическом методе, потому что ключевое слово 'this' возвращает ссылку на текущий экземпляр класса, который его содержит. Статические методы (или любые статические члены) не принадлежат конкретному экземпляру. Они существуют без создания экземпляра класса и вызываются с именем класса не по экземпляру, поэтому мы не можем использовать это ключевое слово в теле статических методов.

Но в случае с методами расширения мы можем использовать его как модификатор параметра метода. Следующий код определяет метод расширения для типа string, который возвращает либо подстроку, либо всю исходную строку, если length больше длины строки (вместо ArgumentOutOfRangeException):



public static string Substr(this string s, int length)
{
    if (s.Length >= length)
    {
        return s.Substring(0, length);
    }
 
    return s;
}
9. В чем разница между методами Dispose и Finalize в C#?
Мы использовали метод Dispose для удаления объектов в .NET. Для этой же цели мы также можем использовать метод Finalize. В чём же разница между ними?

Dispose
Сборщик мусора (GC) играет важную роль в управлении памятью в .NET, поэтому программист может сосредоточиться на функциональности приложения. Сборщик мусора отвечает за освобождение памяти (объектов), которая не используется приложением. Но у него есть ограничение: он может восстанавливать или освобождать только память, которая используется управляемыми ресурсами. Есть несколько ресурсов, которые GC не может высвободить, поскольку у них нет информации о том, как запросить память. Это такие ресурсы, как обработчики файлов, обработчики окон, сетевые сокеты, соединения с базой данных и т.д. Если ваше приложение использует эти ресурсы, то в его ответственности освобождать неуправляемые ресурсы. Например, если мы откроем файл в нашей программе и не закроем его после обработки, этот файл не будет доступен для других операций или использования другим приложением, т.к. они не смогут открыть или изменить этот файл. Для этого класс FileStream предоставляет метод Dispose. Мы должны вызвать этот метод после завершения обработки файла. В противном случае будет выброшено исключение "Access Denied or file is being used by other program" ("Доступ запрещен или файл используется другой программой").

В конечном счёте, реализация интерфейса IDisposable позволяет использовать языковую конструкцию using.

Close или Dispose
Некоторые объекты предоставляют оба метода: и Close, и Dispose. Для потоковых классов (наследников Stream) оба служат одной цели. Метод Dispose вызывает метод Close внутри себя.
Тогда зачем нам метод Dispose в классе Stream? Наличие метода Dispose позволит вам написать приведенный ниже код и неявно вызвать метод Dispose, который, в конечном итоге, вызовет метод Close.

using(FileStream file = new FileStream("path", FileMode.Open, FileAccess.Read))
{
    //Выполняем операции с файлом
}

Но в некоторых классах эти методы ведут себя немного по-разному. Например, класс Connection. Если вызывается метод Close, он отключается от базы данных и освобождает все ресурсы, используемые объектом подключения, а метод Open снова подключает его к базе данных без повторной инициализации объекта подключения. А метод Dispose полностью освобождает объект подключения, и его нельзя открыть, просто вызвав метод Open. Нам придется повторно инициализировать объект Connection.

Создание метода Dispose
Чтобы реализовать освобождение ресурса через метод Dispose для вашего пользовательского класса, вам нужно реализовать интерфейс System.IDisposable. Интерфейс IDisposable предоставляет метод Dispose, в котором будет написан код для освобождения неуправляемого ресурса.

Finalize
Метод Finalize также называется деструктором класса. Его нельзя явно вызвать в коде. Только сборщик мусора может вызывать метод Finalize (финализатор), когда объект становится недоступным. Финализатор не может быть реализован напрямую, только через объявление деструктора. Следующий класс иллюстрирует, как объявить деструктор. Рекомендуется реализовывать методы Finalize и Dispose вместе, если вам нужно реализовать деструктор. После компиляции деструктор становится методом Finalize.

public class MyClass: IDisposable
{
    //Конструктор
    public MyClass()
    {
        //Инициализация
    }
 
    //Деструктор или финализатор
    ~MyClass()
    {
        this.Dispose();
    }
 
    public void Dispose()
    {
        //код для освобождения неуправляемых ресурсов
    }
}
Использование Finalize
Возникает вопрос, когда реализовать финализатор? Это может быть любой неуправляемый ресурс, например файловый поток, объявленный на уровне класса. Возможно, мы не знаем, на какой стадии или на каком шаге программы следует закрыть файл. Этот объект используется во многих местах приложения. Так что в этом сценарии метод Finalize - подходящее место, где может быть освобожден неуправляемый ресурс. Это означает, что память, полученная неуправляемым ресурсом, очищается, как только объект станет недоступен для приложения.
Финализация немного дороже в использовании. Она не очищает память сразу. Когда приложение запускается, сборщик мусора поддерживает отдельную очередь на финализацию, куда он добавляет все объекты, которые должны быть финализированы. Другими словами, сборщик мусора знает, для какого объекта реализован метод Finalize. Когда объект становится недоступным и готов к очистке, сборщик мусора вызывает метод Finalize этого объекта и удаляет его из очереди на финализацию. На этой итерации сбора мусора сборщик просто очищает память, которая используется неуправляемым ресурсом. Память, используемая управляемым ресурсом (самим объектом), все еще находится в куче в качестве недоступной ссылки. Эта память освобождается, когда сборщик мусора запустится в следующий раз. Из-за метода финализации сборщик не очищает всю память, связанную с объектом, с первой попытки.

Заключение
Рекомендуется не реализовывать Dispose и финализаторы без крайней необходимости. Всё сводится к 3 правилам:

Правило первое: не применять (до тех пор, пока это действительно не понадобится).
Правило второе: для класса, владеющего управляемыми ресурсами, реализуйте IDisposable (но не финализатор).
Правило третье: для класса, владеющего неуправляемыми ресурсами, реализуйте IDisposable и финализатор.
10. В чём разница между String и StringBuilder в C#?
Класс String из пространства имён System – это последовательная коллекция символов Unicode (объектов System.Char), представляющая собой текст. Объект String является неизменяемым. Максимальный размер объекта String в памяти составляет 2 ГБ (около 1 миллиарда символов).

Хотя строка является ссылочным типом, операторы равенства (== и !=) Определены для сравнения значений строковых объектов, а не ссылок. Однако после упаковки сравнение происходит на строковых экземплярах:

string a = "hello";
string b = "h";
b += "ello"; // Добавляем к строке 'h'
Console.WriteLine(a==b); // true
Console.WriteLine((object)a == (object)b); // false

Последняя строка выдаёт false, поскольку после упаковки объектов сравниваются ссылки на экземпляры.

С другой стороны, StringBuilder (System.Text) представляет собой изменяемую строку символов. Этот класс не может быть унаследован. Емкость этого объекта по умолчанию составляет 16 символов, а максимальная емкость превышает 2 миллиарда символов.

StringBuilder sb = new StringBuilder();
sb.Append("Hello");
sb.Append("World");
Console.WriteLine(sb.ToString());
Как это работает
Компилятор создает новый строковый объект для каждой конкатенации строк для хранения новой последовательности символов (другими словами, существующей строки и новых данных), и этот новый объект возвращается обратно в переменную.

Например, если вы объединяете две строки, то конкатенация строк выделяет новую строку длины (str1.Length + str2.Length) и копирует первую и вторую строки в эту строку.

Это приводит к многократному повторному копированию строк, например объединение N строк (var result = str1 + str2 + str3 + ... + strN;) потребует N-1 выделения памяти и N-1 операций копирования. Это может стать очень дорогим для больших значений N.

С другой стороны, объект StringBuilder поддерживает буфер для размещения конкатенации новых данных. Новые данные добавляются в буфер, если доступно пространство; в противном случае выделяется новый больший буфер, данные из исходного буфера копируются в новый буфер, а новые данные добавляются в новый буфер.

Например, если вы объединяете 20 строк, StringBuilder просто добавляет одну за другой в свой буфер, а затем возвращает результат по запросу.

Когда что использовать
Не использовать строку, если неизвестно количество конкатенаций или если количество конкатенаций большое:

string x = "";
for (int i = 0; i < 100000; i++)
{
    x += "!";
}

Использовать класс String, если объединяется фиксированное число объектов String. В этом случае компилятор может даже объединить отдельные операции конкатенации в одну операцию, особенно в случае конкатенации строковых литералов:

string x = "Hello" + " " + "World";

С другой стороны, не использовать StringBuilder для тривиальной конкатенации, поскольку выделение и инициализация StringBuilder занимает некоторое время, которое может оказаться бесполезным для небольшого числа конкатенаций:

StringBuilder sb = new StringBuilder();
sb.Append("Hello");
sb.Append("World");
Console.WriteLine(sb.ToString());
Прочие Советы
StringBuilder может быть еще более эффективным при указании размера буфера в конструкторе, чтобы избежать излишних удвоений размера буфера, когда ему не хватает места.
Также, если у есть массив, который нужно объединить в строку, лучше использовать "String.Concat" или "String.Join".
11. Что такое закрытый класс в C#?
Закрытые классы используются для ограничения наследования в объектно-ориентированном программировании. Класс, определённый как закрытый, не может быть унаследован.

В C# для определения закрытого класса используется модификатор sealed. Если создать класс производный от закрытого класса, то компилятор выдаст ошибку.

Все структуры закрыты. Вы не можете унаследовать класс из структуры.

Закрытые методы и свойства
Вы также можете использовать модификатор sealed для метода или свойства, которое переопределяет виртуальный метод или свойство базового класса. Это позволяет вам разрешать классам наследовать от вашего класса, но не позволяет другим разработчикам, использующим ваши классы, переопределять определенные виртуальные методы и свойства.

class X
{
    protected virtual void F()
    {
        Console.WriteLine("X.F");
    }
 
    protected virtual void F2()
    {
        Console.WriteLine("X.F2");
    }
}
 
class Y : X
{
    sealed protected override void F()
    {
        Console.WriteLine("Y.F");
    }
 
    protected override void F2()
    {
        Console.WriteLine("Y.F2");
    }
}
 
class Z : Y
{
    // Попытка переопределить F приводит к ошибке компиляции CS0239.
    protected override void F()
    {
        Console.WriteLine("C.F");
    }
 
    // Допустимо переопределить F2
    protected override void F2()
    {
        Console.WriteLine("Z.F2");
    }
}
Зачем использовать закрытые классы?
Основная цель закрытого класса состоит в том, чтобы запретить наследование от класса. Один из лучших вариантов использования закрытых классов - это класс со статическими членами. Если класс не предназначен для наследования, подклассы могут нарушать инварианты класса. Поэтому, как правило, рекомендуется закрывать любой класс, явно не предназначенный для наследования от него.

В библиотеке классов Microsoft наследование ограничено только теми местами, где оно действительно имеет смысл. Очень многие классы, например String, закрыты. Ключевое слово sealed сообщает CLR, что ниже по иерархии нет классов для поиска методов, что повышает производительность.

12. Что такое частичный класс в C#?
Частичный класс разделяет определение класса на два или более исходных (.cs) файлов. Вы можете создать определение класса в нескольких физических файлах, но при компиляции классов оно будет скомпилировано как один класс.

Преимущества
Вы можете разделить код разработки пользовательского интерфейса и код бизнес-логики, чтобы его было легко читать и понимать. Например, вы разрабатываете веб-приложение с использованием Visual Studio и добавляете новую веб-форму, тогда есть два исходных файла: «aspx.cs» и «aspx.designer.cs». Эти два файла имеют один и тот же класс с частичным ключевым словом. Класс ".aspx.cs" имеет код бизнес-логики, а "aspx.designer.cs" - определение элемента управления пользовательского интерфейса.
При работе с автоматически сгенерированным исходным кодом код можно добавить в класс, не создавая заново исходный файл. Например, вы работаете с LINQ to SQL и создаете файл DBML. Теперь, когда вы перетаскиваете таблицу, она создает частичный класс в designer.cs, и все столбцы таблицы имеют свойства в этом классе. Допустим, вам нужно добавить столбцы к этой таблице без добавления столбцов в таблицу базы данных. Вы можете создать отдельный файл для этого класса, который имеет свойства для этих столбцов, и будет частичным классом. То есть вы можете написать свой код, не вмешиваясь в код, сгенерированный системой.
Несколько разработчиков могут одновременно работать с кодом одного и того же класса.
Вы можете лучше поддерживать свое приложение, сжимая большие классы. Предположим, у вас есть класс с несколькими интерфейсами, поэтому вы можете создавать несколько исходных файлов для реализации каждого интерфейса. Легко понять и поддерживать реализацию интерфейса, в отдельном файле частичного класса.

public interface IRegister
{
    //Функционал регистрации
}
 
public interface ILogin
{
    //Функционал входа в систему
}
 
//Файл UserRegister.cs
public partial class User : IRegister, ILogin
{
    //реализация IRegister
}
 
//Файл UserLogin.cs
public partial class User
{
    //реализация ILogin
}
Некоторые моменты, на которые стоит обратить внимание:
Вам нужно использовать ключевое слово partial в каждой части частичного класса.
Имя каждой части частичного класса должно быть одинаковым, но имена файлов для каждой части частичного класса могут быть разными.
Все части частичного класса должны находиться в одном пространстве имен.
Каждая часть частичного класса должна находиться в одной сборке или DLL, другими словами, вы не можете создать частичный класс в исходных файлах другого проекта библиотеки классов.
Каждая часть частичного класса должна иметь одинаковый уровень доступа.
Если вы наследуете класс или интерфейс в частичном классе, то он наследуется во всех частях частичного класса.
Если часть частичного класса закрыта от наследования, тогда весь класс будет закрыт.
Если часть частичного класса является абстрактной, тогда весь класс будет абстрактным.
Как частичные классы используются в реальности?
В реальности, в прикладном коде, использование partial говорит о проблемах в коде:

Если класс получается настолько большим, что его нужно разбивать на отдельные файлы, то это означает, что класс нуждается декомпозиции. Вероятнее всего у класса слишком много обязанностей или дублирования кода.
Если частичные классы используются для того, чтобы несколько разработчиков могли работать с одним классом - пора начать использовать системы контроля версий. Например, git. Если в рамках одного класса возникает слишком много конфликтов в результате параллельной работы разработчиков - класс нуждается в декомпозиции.
13. В чем разница между поздним и ранним связыванием в C#?
Концепции раннего связывания и позднего связывания относятся к полиморфизму в C#. Полиморфизм - это особенность объектно-ориентированного программирования, позволяющая языку использовать одно и то же имя метода в разных формах.

Есть 2 способа достижения этого:

Во время компиляции – статический полиморфизм, раннее связывание или перегрузка (overloading).
Во время выполнения – динамический полиморфизм, позднее связывание или переопределение (overriding).
Полиморфизм времени компиляции или раннее связывание
При перегрузке методы имеют одно и то же имя, но разные сигнатуры. Это также известно, как полиморфизм времени компиляции, поскольку решение о том, какой метод вызывать, принимается во время компиляции. Компилятор C# проверяет количество передаваемых параметров и типы параметров и принимает решение, какой метод вызывать, либо выдаёт ошибку времени компиляции, если подходящий метод не найден:

public class TestData
{
    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }
 
    public int Add(int a, int b)
    {
        return a + b;
    }
}
…
TestData data = new TestData();
int sum1 = dataClass.Add(45, 34, 67);
int sum2 = dataClass.Add(23, 34);


Полиморфизм времени выполнения или позднее связывание
Здесь имена и сигнатуры методов (количество параметров и типы параметров) должны быть одинаковыми, однако методы могут иметь различную реализацию. Переопределение метода может быть выполнено с использованием наследования. Компилятор решает, какой метод вызывать, во время выполнения. Если доступен переопределённый метод, будет вызван он, в противном случае будет вызван метод базового класса. В следующем примере классы A и B переопределяют метод ToString базового класса object. Поэтому при выводе их в консоль будут использованы переопределённые версии, а при выводе класса C будет использован метод ToString базового класса object:

public class A
{
    public override string ToString() => "Class A";
}
 
public class B
{
    public override string ToString() => "Class B";
}
 
public class C {}
 
…
 
var objects = new object[] { new A(), new B(), new C() };
foreach (var obj in objects)
{
    Console.WriteLine(obj);
}
Вывод:



Class A
 
Class B
 
ConsoleApp1.C


14. В чём разница между IEnumerable и IQueryable?
При работе с базой данных иногда можно запутаться. Могут возникнуть некоторые вопросы, например, что использовать для извлечения данных из БД, IEnumerable или IQueryable?

Если коротко:

IEnumerable - выполняет запрос SELECT на стороне сервера, загружает все данные в память на стороне клиента, а затем выполняет фильтрацию.
IQueryable - выполняет запрос SELECT на стороне сервера со всеми фильтрами.
Разница в том, что IQueryable<T> - это интерфейс, который позволяет работать LINQ-to-SQL (на самом деле, LINQ-to-чтоугодно). Поэтому, если вы дополнительно уточните свой запрос в IQueryable<T>, этот запрос будет выполнен в базе данных, если это возможно.

В случае IEnumerable<T> это будет LINQ-to-object, то есть все объекты, соответствующие исходному запросу, должны быть загружены в память из базы данных:

IQueryable<Customer> custs = ...;
// Затем...
var goldCustomers = custs.Where(c => c.IsGold);
Этот код выполнит SQL-запрос для выбора только золотых клиентов. А вот следующий код выполнит исходный запрос к базе данных, а затем отфильтрует не-золотых клиентов в памяти:

IEnumerable<Customer> custs = ...;
// Затем...
var goldCustomers = custs.Where(c => c.IsGold);
Это довольно важное различие, и работа с IQueryable может во многих случаях избавить вас от возвращения слишком большого количества строк из базы данных. Другим ярким примером является разбиение на страницы: если вы используете Take и Skip с IQueryable, вы получите только запрошенные строки, а выполнение этого в IEnumerable приведет к загрузке в память всех строк.

По сути, есть два идентичных набора расширений LINQ. Where, Sum, Count, FirstOrDefault и т.д. имеют две версии: одна, которая принимает функции, и другая, которая принимает выражения.

Сигнатура для IEnumerable: Where(Func<Customer, bool> predicate)
Сигнатура для IQueryable: Where(Expression<Func<Customer, bool>> predicate)
Вы, вероятно, использовали обе версии, не осознавая этого, потому что обе вызываются с использованием идентичного синтаксиса Where(x => x.City == "<City>"), который работает как для IEnumerable, так и для IQueryable.

При использовании Where с IEnumerable компилятор передает в Where скомпилированную функцию. А при использовании Where с IQueryable компилятор передает в Where дерево выражений. Дерево выражений похоже на отражение, но для кода. Компилятор преобразует ваш код в структуру данных, которая описывает, что ваш код делает в формате, который легко усваивается.

Зачем заморачиваться с этими деревьями выражений? Я просто хочу, чтобы Where фильтровал мои данные. Основная причина в том, что Entity Framework и Linq2SQL могут преобразовывать деревья выражений непосредственно в SQL, что может быть критично при обработке большого объема данных.

То есть надо везде использовать AsQueryable?
Нет, IQueryable полезен, только если базовый поставщик данных может что-то с ним сделать. Преобразование обычного List в IQueryable не даст вам никакой выгоды.

Еще один случай, когда нужно использовать AsQueryable(), это передача набора данных в метод с сигнатурой IQueryable<T>.

А как правильно материализовать IQuaryable?
Есть два метода для явной материализации IQuaryable. Это ToList() и ToArray().

С одной стороны выбор метода материализации должен быть основан на контракте. То есть если подразумевается, что дальше по коду результат будет использован только для чтения, то логичнее использовать ToArray(). ToList() в этом случае нужен, если подразумевается дальнейшая модификация коллекции.

С другой стороны, оба эти метода под капотом используют массив для хранения. Судя по исходным кодам платформы, ToList() для малых объемов данных более производительный, т.к. выделяет столько памяти, сколько действительно требуется. В отличии от ToArray(), который сначала создаст массив максимальной длины. А затем выберет результирующий массив на столько элементов, сколько действительно было в коллекции.

Итого, наиболее эффективным подходом может оказаться такой. Если контракт подразумевает получение коллекции только на чтение, то можно вызвать ToList() и привести его к IReadOnlyCollection<T>(). Этот интерфейс наиболее точно передаёт смысл контракта по сравнению с возвращаемым массивом. Который, строго говоря, является техническим, внутренним типом.

Замеры
|  Method | ElementCount |         Mean |      Error |     StdDev |
|-------- |------------- |-------------:|-----------:|-----------:|
| ToArray |           10 |     1.711 us |  0.0103 us |  0.0086 us |
|  ToList |           10 |     1.632 us |  0.0220 us |  0.0205 us |
| ToArray |         1000 |    14.452 us |  0.1922 us |  0.1798 us |
|  ToList |         1000 |    14.436 us |  0.1319 us |  0.1234 us |
| ToArray |       100000 | 1,223.808 us | 10.8329 us |  9.6031 us |
|  ToList |       100000 | 1,323.671 us | 16.1367 us | 14.3048 us |


15. В чем разница между Array.CopyTo() и Array.Clone()?
Метод Clone() возвращает новый объект массива (неглубокая копия), содержащий все элементы в исходном массиве. Метод CopyTo() копирует элементы в другой существующий массив. Оба выполняют неглубокое копирование, то есть каждый элемент массива будет содержать ссылки на те же объекты, что и элементы в исходном массиве. Глубокая копия (которую не выполняет ни один из этих методов) создаёт новый экземпляр объекта каждого элемента, в результате чего получится другой, но идентичный объект. Однако есть различия и рекомендации по использованию этих методов.

System.Array.Clone
Медленнее, чем CopyTo, вероятно, потому что использует Object.MemberwiseClone;
Требуется приведение результата к соответствующему типу;
Полученный массив имеет ту же длину, что и исходный.
Не требуется целевой массив.
System.Array.CopyTo
Быстрее, чем Clone при копировании в массив того же типа;
Вызывает Array.Copy, наследуя некоторые его полезные возможности:
может вставлять элементы типа значения в элементы ссылочного типа, например, копируя массив int[] в object[];
может распаковывать элементы ссылочного типа в элементы значимого типа, например, копируя массив object[] из упакованных элементов int в массив int[];
может выполнять расширенные преобразования для типов значений, например, копируя int[] в long[];
может выполнять даункаст элементов, например, копируя массив Stream[] в MemoryStream[] (если какой-либо элемент в исходном массиве не конвертируется в MemoryStream, генерируется исключение);
позволяет скопировать источник в целевой массив, длина которого больше, чем у источника.
Требуется целевой массив.
Выглядит, что System.Array.CopyTo имеет больше достоинств?
В итоге, оба этих метода - это реализация интерфейсов ICloneable и ICollection. Если нужно скопировать массив, то лучше использовать Array.Copy или Array.ConstrainedCopy. Метод Array.ConstrainedCopy гарантирует, что если операция копирования завершится неудачей, то состояние целевого массива не будет повреждено.

16. Что такое модификаторы доступа в C#?
Модификаторы доступа в C# используются для определения области доступности класса или его членов. Например, открытый класс доступен всем без каких-либо ограничений, тогда как внутренний класс может быть доступен только внутри сборки.
Модификаторы доступа являются неотъемлемой частью объектно-ориентированного программирования, используются для реализации инкапсуляции и позволяют вам определить, кто имеет, а кто не имеет доступа к определенным функциям.

Модификаторы доступа в С#
public - доступ к типу или члену может быть получен из любого другого кода в той же сборке или другой сборке, которая на него ссылается.
private - тип или член могут быть доступны только из кода в том же классе или структуре.
protected - доступ к типу или члену возможен только из кода в том же классе или в классе, производном от него.
internal - доступ к типу или члену возможен из любого кода в той же сборке, но не из другой сборки.
protected internal – доступ к типу или члену возможен из любого кода в сборке, в которой он объявлен, или из производного от этого класса в другой сборке.
private protected (с C#7.2) - доступ к типу или члену возможен только в пределах его сборки, и из кода в том же классе или в классе, производном от него.
Особенности
Классы, структуры, интерфейсы и делегаты могут быть public или internal (по умолчанию).
Члены класса, включая вложенные классы и структуры, могут иметь все возможные модификаторы доступа (по умолчанию private).
Члены структуры, включая вложенные классы и структуры, могут быть объявлены как public, internal или private. Члены структуры не могут быть protected, потому что структуры не поддерживают наследование.
Члены интерфейсов и перечислений всегда public, т.к. это контракт общения с внешним миром. Модификаторы доступа к ним не применяются (это не правда после C#8).
Тип любого поля, свойства или события должен быть, как минимум, таким же доступным, как и сам член. Аналогично, тип возвращаемого значения и типы параметров любого метода, индексатора или делегата, должны быть, как минимум, такими же доступными, как и сам член. Т.е вы не можете иметь public метод M, который возвращает класс C, если C не public. Или вы не можете иметь protected свойство типа A, если тип A private.
Производные классы не могут иметь большей доступности, чем их базовые типы. Т.е. не может быть public класса B, производного от internal класса A.
Финализаторы не могут иметь модификаторов доступа.
Пользовательские операторы всегда должны быть объявлены как public.
Замечание: Вы можете разрешить другим сборкам доступ к вашим внутренним типам с помощью атрибута InternalsVisibleToAttribute. Но если это требуется в прикладном коде, скорее всего это ошибка проектирования.

Защищает ли модификатор доступа от взлома класса?
Нет. Единственное назначение модификаторов - показать потребителю кода, какие члены являются внутренними, а какие - интерфейсными.

Неосторожный вызов внутренних методов и изменение внутренних полей может вывести объект из строя. Разработчик класса может гарантировать работоспособность только при соблюдении интерфейса.

Внутренние методы и поля могут изменяться на усмотрение разработчика без изменения интерфейса класса. Таким образом интерфейс класса стабильнее для потребляющего кода, чем его внутреннее устройство.

Как получить доступ к закрытым членам класса?
Через механизм рефлексии.

Например, получение внутренних полей класса:

FieldInfo[] fields = myType.GetFields(
                         BindingFlags.NonPublic |
                         BindingFlags.Instance);


17. Что такое виртуальный метод в C#?
Виртуальный метод - это метод, который можно переопределить в производных классах. Виртуальный метод имеет реализацию в базовом классе. Он используется, когда базовая функциональность метода одинакова, но иногда требуется больше функциональности в производном классе. В базовом классе создается виртуальный метод, используя ключевое слово virtual, который можно переопределить в производном классе с помощью ключевого слова override.

Производному классу необязательно переопределять этот метод.
Когда вызывается виртуальный метод, тип объекта во время выполнения проверяется для переопределяющего члена. Вызывается переопределяющий член в наиболее производном классе. То есть может быть вызван и исходный член, если ни один производный класс не переопределил его.
По умолчанию методы не виртуальные. Нельзя переопределить не виртуальный метод.
Нельзя использовать виртуальный модификатор с модификаторами static, abstract, private или override.
Абстрактные методы обязательны для переопределения в классе-потомке.
18. В чём разница между Array и ArrayList в C#?
ArrayList - это динамический массив. Он хранит значения как объекты и изменяет размер места хранения по мере необходимости.

Ключевые методы
1. BinarySearch - возвращает позицию объекта поиска в виде целочисленного значения.
2. Insert - вставляет элемент в указанное место по индексу.
3. InsertRange - вставляет элементы как отдельные объекты в указанное место.
4. Remove - удаляет первое появление данного объекта.
5. RemoveAt - удаляет элемент по индексу.
6. RemoveRange - удаляет набор элементов из указанного диапазона.
7. Sort - выполняет сортировку элементов в порядке возрастания.
8. Reverse – упорядочивает элементы в обратном порядке.

Преимущества
1. Не хранит определённые типы данных, хранит все как объекты.
2. Нет необходимости явно выделять и освобождать место для хранения данных.
3. Имеет явные методы сортировки.
4. Может вставлять и удалять элементы между позициями.
5. Может хранить объекты.

Недостатки
1. Не является строго типизированным. Нужно выполнять приведение типов при извлечении контента. Это сказывается на производительности.
2. Использует для хранения LinkedList, поэтому для вставки или удаления по определенной позиции выполняется обход всех адресов хранения.
3. Может приводить к ошибке времени выполнения, если реальный тип элемента не будет совпадать с желаемым.

Разница между Array и ArrayList
Array
- Использует векторный массив для хранения элементов
- Размер массива должен быть определен до использования.
- Хранит данные определенного типа.
- Нет необходимости выполнять приведение типов.
- Нет методов для сортировки и вставки/удаления элементов.

ArrayList
- Использует связанный список для хранения элементов.
- Нет необходимости указывать размер хранилища.
- Хранить все элементы как объекты.
- Необходимо выполнять приведение типов.
- Имеет методы для вставки, удаления, сортировки и поиска элементов.

Где используется Array или ArrayList в современных приложениях?
Нигде или крайне редко. Предпочтительнее использовать generic-коллекции.
